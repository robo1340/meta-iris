//standard includes
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <assert.h>
#include <time.h>

#include "turbo_wrapper.h"
#include "print_util.h"

//int r = rand();      // Returns a pseudo-random integer between 0 and RAND_MAX.

void test_bit_utils(void){
	srand(time(NULL));   // Initialization, should only be called once.
	int i;
	int rc;
	/*
	uint8_t u2[2] = {0x0F, 0x0F};
	uint8_t u16[16] = {0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1};
	int8_t  s16[16] = {-128,-128,-128,-128,127,127,127,127,-128,-128,-128,-128,127,127,127,127};
	
	uint8_t u12[12] = {1,1,0,0,1,1,0,0,1,1};
	uint8_t u2b[2] = {0xCC, 0xC0};

	uint8_t out[24];
	memset(out, 0, sizeof(out));

	
	rc = bytes2bits(u2, sizeof(u2), out, sizeof(u16));
	assert(rc==sizeof(u16));
	assert(memcmp(out, u16, sizeof(u16))==0);
	
	memset(out, 0, sizeof(out));
	rc = bits2bytes(u12, sizeof(u12), out, sizeof(u2b));
	assert(rc == sizeof(u2b));
	assert(memcmp(out, u2b, sizeof(u2b))==0);
	
	memset(out, 0, sizeof(out));
	rc = bytes2bits_ranged(u2, sizeof(u2), (int8_t*)out, sizeof(u16));
	assert(rc==sizeof(s16));
	assert(memcmp(out, s16, sizeof(s16))==0);
	*/
	uint8_t in[10] = {1,2,3,4,5,6,7,8,9,10};
	uint8_t tmp[80];
	uint8_t out2[10];
	memset(out2, 0, sizeof(out2));
	
	rc = bytes2bits(in, sizeof(in), tmp, sizeof(tmp));
	assert(rc==sizeof(tmp));
	rc = bits2bytes(tmp, sizeof(tmp), out2, sizeof(out2));
	assert(rc == sizeof(out2));
	assert(memcmp(in, out2, sizeof(out2))==0);
	
	uint8_t in2[CODED_BIT_LEN];
	uint8_t tmp2[CODED_LEN];
	uint8_t out3[CODED_BIT_LEN+4];
	for (i=0; i<sizeof(in2); i++){
		in2[i] = i%2;
	}
	memset(out3,0,sizeof(out3));
	
	
	rc = bits2bytes(in2, sizeof(in2), tmp2, sizeof(tmp2));
	assert(rc==sizeof(tmp2));
	rc = bytes2bits(tmp2, sizeof(tmp2), out3, sizeof(out3));
	assert(rc == sizeof(out3));
	assert(memcmp(in2, out3, sizeof(in2))==0);
	
}

/* Bit error rate test */
static int error_test(void){
	int i, ober = 0;
	
	uncoded_block_t in;
	uncoded_block_t out;
	coded_block_t ch;
	
	for (i=0; i<sizeof(in); i++){
		in.data[i] = i%255;
	}
	
	assert(turbo_wrapper_encode(&in, &ch));
	
	//send over channel, simulate errors
	for (i=0; i<sizeof(ch.data); i++){
		if ((i%33) == 0){
			ch.data[i] = ~ch.data[i];
		}
	}
	//the channel
	
	assert(turbo_wrapper_decode(&ch, &out));

	for (i=0, ober=0; i<sizeof(in.data); i++) {
		if (in.data[i] != out.data[i]) {ober++;}
	}
	printf("FER....%d\n", ober);

	assert(memcmp(in.data, out.data, UNCODED_LEN)==0);
	

	return 0;
}

/* Bit error rate test */
static int error_test2(void){
	int i, ober = 0;
	
	uint8_t in[] = {0x69,0x72,0x69,0x73,0x5f,0x32,0x34,0x00,0x00,0x9e,0x3b,0x35,0xee,0x02,0x82,0xba,0xd9,0xcc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
	assert(sizeof(in) == UNCODED_LEN);
	
	//uncoded_block_t out;
	coded_block_t ch;
	
	assert(turbo_wrapper_encode((uncoded_block_t*)&in, &ch));
	
	//printArrHex(ch.data, sizeof(ch.data));
	
	
	/*
	//send over channel, simulate errors
	for (i=0; i<sizeof(ch.data); i++){
		if ((i%33) == 0){
			ch.data[i] = ~ch.data[i];
		}
	}
	//the channel
	
	assert(turbo_wrapper_decode(&ch, &out));

	for (i=0, ober=0; i<sizeof(in.data); i++) {
		if (in.data[i] != out.data[i]) {ober++;}
	}
	printf("FER....%d\n", ober);

	assert(memcmp(in.data, out.data, UNCODED_LEN)==0);
	*/

	return 0;
}

int main(void) {

	test_bit_utils();
	
	assert(turbo_wrapper_init(0));
	error_test();
	error_test2();
	assert(turbo_wrapper_deinit());
	
	printf("Test passed!\n");
}
